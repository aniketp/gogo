// Code generated by gocc; DO NOT EDIT.

package parser

import (
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/shivansh/gogo/src/utils"
	"github.com/shivansh/gogo/tmp/token"
)

// Node represents a node in the AST of a given program.
type Node struct {
	place string   // variable storing the value if node represents an expression
	code  []string // IR instructions
}

type symTabType map[string][]string

type SymInfo struct {
	varSymTab symTabType
	parent    *SymInfo
}

// DeferStackItem is an individual item stored when a call to defer is made. It
// contains the code for the corresponding function call which is placed at the
// end of function body.
type DeferStackItem []string

var (
	tmpIndex   int
	labelIndex int
	varIndex   int
	// funcSymtabCreated keeps track whether a symbol table corresponding to a
	// function declaration has to be instantiated. This is because usually
	// a new symbol table is created when the corresponding block begins.
	// However, in case of functions the arguments also need to be added to
	// the symbol table. Thus the symbol table is instantiated when the
	// production rule corresponding to the arguments is reached and not
	// when the block begins.
	funcSymtabCreated bool
	symTab            symTabType // symbol table for temporaries ; TODO: Update this.
	// currSymTab keeps track of the currently active symbol table
	// depending on scope.
	currSymTab *SymInfo
	// globalSymTab keeps track of the global struct and function declarations.
	// NOTE: structs and functions can only be declared globally.
	globalSymTab symTabType
	// deferStack stores the deferred function calls which are then called
	// when the surrounding function block ends.
	deferStack *utils.Stack
	re         *regexp.Regexp
)

func init() {
	symTab = make(symTabType)
	globalSymTab = make(symTabType)
	deferStack = utils.CreateStack()
	re = regexp.MustCompile("(^-?[0-9]+$)") // integers
}

// SearchInScope returns the symbol table entry for a given variable in the
// current scope. If not found, the parent symbol table is looked up until the
// topmost symbol table is reached. If not found in all these symbol tables,
// then the global symbol table is looked up which contains the entries
// corresponding to structs and functions.
func SearchInScope(v string) ([]string, bool) {
	currScope := currSymTab
	for currScope != nil {
		symTabEntry, ok := currScope.varSymTab[v]
		if ok {
			return symTabEntry, true
		} else {
			currScope = currSymTab.parent
		}
	}
	// Lookup in global scope in case the variable corresponds to a struct
	// or a function name.
	for k, symTabEntry := range globalSymTab {
		if k == v {
			return symTabEntry, true
		}
	}
	return []string{}, false
}

// GetRealName extracts the original name of variable from its renamed version.
func GetRealName(s string) string {
	realName := ""
	for i := 0; i < len(s); i++ {
		if s[i] == '.' {
			break
		} else {
			realName = realName + string(s[i])
		}
	}
	return realName
}

// NewTmp generates a unique temporary variable.
func NewTmp() string {
	t := fmt.Sprintf("t%d", tmpIndex)
	tmpIndex++
	return t
}

// NewLabel generates a unique label name.
func NewLabel() string {
	l := fmt.Sprintf("l%d", labelIndex)
	labelIndex++
	return l
}

// NewVar generates a unique variable name used for renaming. A variable named
// var will be renamed to 'var.int_lit' where int_lit is an integer. Since
// variable names cannot contain a '.', this will not result in a naming
// conflict with an existing variable. The renamed variable will only occur in
// the IR (there is no constraint on variable names in IR as of now).
func RenameVariable(v string) string {
	ret := fmt.Sprintf("%s.%d", v, varIndex)
	varIndex++
	return ret
}

type (
	//TODO: change type and variable names to be consistent with other tables
	ProdTab      [numProductions]ProdTabEntry
	ProdTabEntry struct {
		String     string
		Id         string
		NTType     int
		Index      int
		NumSymbols int
		ReduceFunc func([]Attrib) (Attrib, error)
	}
	Attrib interface {
	}
)

var productionsTable = ProdTab{
	ProdTabEntry{
		String: `S' : Start	<<  >>`,
		Id:         "S'",
		NTType:     0,
		Index:      0,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `Start : SourceFile	<< func() (Attrib, error) {
	        re := regexp.MustCompile("\n(\n)*")
                c := X[0].(Node).code
                for _, v := range c {
                        v := strings.TrimSpace(v)
                        // Compress multiple newlines within IR statements into
                        // a single newline.
                        v = re.ReplaceAllString(v, "\n")
                        if v != "" {
                                fmt.Println(v)
                        }
                }
                return nil, nil
        } () >>`,
		Id:         "Start",
		NTType:     1,
		Index:      1,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				re := regexp.MustCompile("\n(\n)*")
				c := X[0].(Node).code
				for _, v := range c {
					v := strings.TrimSpace(v)
					// Compress multiple newlines within IR statements into
					// a single newline.
					v = re.ReplaceAllString(v, "\n")
					if v != "" {
						fmt.Println(v)
					}
				}
				return nil, nil
			}()
		},
	},
	ProdTabEntry{
		String: `SourceFile : RepeatTopLevelDecl	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "SourceFile",
		NTType:     2,
		Index:      2,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatTopLevelDecl : TopLevelDecl RepeatTopLevelDecl	<< func() (Attrib, error) {
                              n := Node{"", X[0].(Node).code}
                              n.code = append(n.code, X[1].(Node).code...)
                              return n, nil
                        } () >>`,
		Id:         "RepeatTopLevelDecl",
		NTType:     3,
		Index:      3,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[1].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatTopLevelDecl : empty	<< func() (Attrib, error) {
                              return Node{"", []string{}}, nil
                        } () >>`,
		Id:         "RepeatTopLevelDecl",
		NTType:     3,
		Index:      4,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `TopLevelDecl : Declaration RepeatTerminator	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "TopLevelDecl",
		NTType:     4,
		Index:      5,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `TopLevelDecl : FunctionDecl RepeatTerminator	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "TopLevelDecl",
		NTType:     4,
		Index:      6,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Declaration : ConstDecl	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Declaration",
		NTType:     5,
		Index:      7,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Declaration : TypeDecl	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                    } () >>`,
		Id:         "Declaration",
		NTType:     5,
		Index:      8,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Declaration : VarDecl	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Declaration",
		NTType:     5,
		Index:      9,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `VarDecl : kwdVar VarSpec	<< func() (Attrib, error) {
                    return Node{"", X[1].(Node).code}, nil
            } () >>`,
		Id:         "VarDecl",
		NTType:     6,
		Index:      10,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `VarSpec : IdentifierList Type	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range X[0].(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, 0", renamedVar))
                        }
                        return n, nil
                } () >>`,
		Id:         "VarSpec",
		NTType:     7,
		Index:      11,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				for _, v := range X[0].(Node).code {
					renamedVar := RenameVariable(v)
					currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
					n.code = append(n.code, fmt.Sprintf("=, %s, 0", renamedVar))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `VarSpec : IdentifierList Type "=" ExpressionList	<< func() (Attrib, error) {
                        n := Node{"", X[3].(Node).code}
                        expr := utils.SplitAndSanitize(X[3].(Node).place, ",")
                        for k, v := range X[0].(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                        }
                        return n, nil
                } () >>`,
		Id:         "VarSpec",
		NTType:     7,
		Index:      12,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[3].(Node).code}
				expr := utils.SplitAndSanitize(X[3].(Node).place, ",")
				for k, v := range X[0].(Node).code {
					renamedVar := RenameVariable(v)
					currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
					n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `VarSpec : IdentifierList "=" ExpressionList	<< func() (Attrib, error) {
                        n := Node{"", X[2].(Node).code}
                        expr := utils.SplitAndSanitize(X[2].(Node).place, ",")
                        for k, v := range X[0].(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                        }
                        return n, nil
                } () >>`,
		Id:         "VarSpec",
		NTType:     7,
		Index:      13,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[2].(Node).code}
				expr := utils.SplitAndSanitize(X[2].(Node).place, ",")
				for k, v := range X[0].(Node).code {
					renamedVar := RenameVariable(v)
					currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
					n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `VarSpec : empty	<< func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>`,
		Id:         "VarSpec",
		NTType:     7,
		Index:      14,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `TypeDecl : kwdType TypeSpec	<< func() (Attrib, error) {
                        typeInfo := utils.SplitAndSanitize(X[1].(Node).place, ",")
                        structName := strings.TrimSpace(typeInfo[1])
                        switch strings.TrimSpace(typeInfo[0]) {
                        case "struct":
                                // Create a global symbol table entry.
                                // NOTE: The symbol table entry of a struct is of the form -
                                //      structName : []{"struct", memberName1, memberType1, memberName2, memberType2, ...}
                                globalSymTab[structName] = []string{"struct"}
                                globalSymTab[structName] = append(globalSymTab[structName], X[1].(Node).code...)
                        default: // TODO: Add remaining types.
                                return nil, errors.New("Unknown type")
                        }
                        // TODO: Member initialization will be done when a new object is instantiated.
                        return Node{"", []string{}}, nil
                } () >>`,
		Id:         "TypeDecl",
		NTType:     8,
		Index:      15,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				typeInfo := utils.SplitAndSanitize(X[1].(Node).place, ",")
				structName := strings.TrimSpace(typeInfo[1])
				switch strings.TrimSpace(typeInfo[0]) {
				case "struct":
					// Create a global symbol table entry.
					// NOTE: The symbol table entry of a struct is of the form -
					//      structName : []{"struct", memberName1, memberType1, memberName2, memberType2, ...}
					globalSymTab[structName] = []string{"struct"}
					globalSymTab[structName] = append(globalSymTab[structName], X[1].(Node).code...)
				default: // TODO: Add remaining types.
					return nil, errors.New("Unknown type")
				}
				// TODO: Member initialization will be done when a new object is instantiated.
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `TypeSpec : TypeDef	<< func() (Attrib, error) {
                return Node{X[0].(Node).place, X[0].(Node).code}, nil
            } () >>`,
		Id:         "TypeSpec",
		NTType:     9,
		Index:      16,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `TypeDef : identifier Type	<< func() (Attrib, error) {
                    return Node{fmt.Sprintf("%s, %s", X[1].(Node).place, string(X[0].(*token.Token).Lit)), X[1].(Node).code}, nil
             } () >>`,
		Id:         "TypeDef",
		NTType:     10,
		Index:      17,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{fmt.Sprintf("%s, %s", X[1].(Node).place, string(X[0].(*token.Token).Lit)), X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ConstDecl : kwdConst ConstSpec	<< func() (Attrib, error) {
                        return Node{"", X[1].(Node).code}, nil
                } () >>`,
		Id:         "ConstDecl",
		NTType:     11,
		Index:      18,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ConstSpec : IdentifierList	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range X[0].(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, 0", renamedVar))
                        }
                        return n, nil
                } () >>`,
		Id:         "ConstSpec",
		NTType:     12,
		Index:      19,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				for _, v := range X[0].(Node).code {
					renamedVar := RenameVariable(v)
					currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
					n.code = append(n.code, fmt.Sprintf("=, %s, 0", renamedVar))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ConstSpec : IdentifierList "=" ExpressionList	<< func() (Attrib, error) {
                        n := Node{"", X[2].(Node).code}
                        expr := utils.SplitAndSanitize(X[2].(Node).place, ",")
                        for k, v := range X[0].(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"}
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                        }
                        return n, nil
                } () >>`,
		Id:         "ConstSpec",
		NTType:     12,
		Index:      20,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[2].(Node).code}
				expr := utils.SplitAndSanitize(X[2].(Node).place, ",")
				for k, v := range X[0].(Node).code {
					renamedVar := RenameVariable(v)
					currSymTab.varSymTab[v] = []string{renamedVar, "int"}
					n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ExpressionList : Expression	<< func() (Attrib, error) {
                                return Node{X[0].(Node).place, X[0].(Node).code}, nil
                        } () >>`,
		Id:         "ExpressionList",
		NTType:     13,
		Index:      21,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ExpressionList : Expression "," ExpressionList	<< func() (Attrib, error) {
                                n := Node{"", X[0].(Node).code}
                                n.code = append(n.code, X[2].(Node).code...)
                                n.place = fmt.Sprintf("%s,%s", X[0].(Node).place, X[2].(Node).place)
                                return n, nil
                        } () >>`,
		Id:         "ExpressionList",
		NTType:     13,
		Index:      22,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				n.place = fmt.Sprintf("%s,%s", X[0].(Node).place, X[2].(Node).place)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Expression : Expression "||" Term1	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("or, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>`,
		Id:         "Expression",
		NTType:     14,
		Index:      23,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				n.place = NewTmp()
				n.code = append(n.code, fmt.Sprintf("or, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
				n.code = append(n.code, "\n")
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Expression : Term1	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Expression",
		NTType:     14,
		Index:      24,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term1 : Term1 "&&" Term2	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("and, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>`,
		Id:         "Term1",
		NTType:     15,
		Index:      25,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				n.place = NewTmp()
				n.code = append(n.code, fmt.Sprintf("and, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
				n.code = append(n.code, "\n")
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term1 : Term2	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Term1",
		NTType:     15,
		Index:      26,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term2 : Term2 RelOp Term3	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        branchOp := ""
                        n.place = NewTmp()
                        falseLabel := NewLabel()
                        afterLabel := NewLabel()
                        switch X[1].(Node).place {
                                case "==":
                                        branchOp = "bne"
                                case "!=":
                                        branchOp = "beq"
                                case "<=":
                                        branchOp = "bgt"
                                case "<":
                                        branchOp = "bge"
                                case ">=":
                                        branchOp = "blt"
                                case ">":
                                        branchOp = "ble"
                        }
                        n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", branchOp, falseLabel, X[0].(Node).place, X[2].(Node).place))
                        n.code = append(n.code, fmt.Sprintf("=, %s, 1", n.place))
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", falseLabel))
                        n.code = append(n.code, fmt.Sprintf("=, %s, 0", n.place))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "Term2",
		NTType:     16,
		Index:      27,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				branchOp := ""
				n.place = NewTmp()
				falseLabel := NewLabel()
				afterLabel := NewLabel()
				switch X[1].(Node).place {
				case "==":
					branchOp = "bne"
				case "!=":
					branchOp = "beq"
				case "<=":
					branchOp = "bgt"
				case "<":
					branchOp = "bge"
				case ">=":
					branchOp = "blt"
				case ">":
					branchOp = "ble"
				}
				n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", branchOp, falseLabel, X[0].(Node).place, X[2].(Node).place))
				n.code = append(n.code, fmt.Sprintf("=, %s, 1", n.place))
				n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", falseLabel))
				n.code = append(n.code, fmt.Sprintf("=, %s, 0", n.place))
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term2 : Term3	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Term2",
		NTType:     16,
		Index:      28,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term3 : Term3 "+" Term4	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        if re.MatchString(X[0].(Node).place) && re.MatchString(X[2].(Node).place) {
                                // expression is of the form 1+2
                                term3val, err := strconv.Atoi(X[0].(Node).place)
                                if err != nil {
                                        return nil, err
                                }
                                term4val, err := strconv.Atoi(X[2].(Node).place)
                                if err != nil {
                                        return nil, err
                                }
                                n.place = strconv.Itoa(term3val + term4val)
                        } else if re.MatchString(X[0].(Node).place) {
                                // expression is of the form 1+b, which is to be converted to b+1
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("+, %s, %s, %s", n.place, X[2].(Node).place, X[0].(Node).place))
                                n.code = append(n.code, "\n")
                        } else {
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("+, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
                                n.code = append(n.code, "\n")
                        }
                        return n, nil
                } () >>`,
		Id:         "Term3",
		NTType:     17,
		Index:      29,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				if re.MatchString(X[0].(Node).place) && re.MatchString(X[2].(Node).place) {
					// expression is of the form 1+2
					term3val, err := strconv.Atoi(X[0].(Node).place)
					if err != nil {
						return nil, err
					}
					term4val, err := strconv.Atoi(X[2].(Node).place)
					if err != nil {
						return nil, err
					}
					n.place = strconv.Itoa(term3val + term4val)
				} else if re.MatchString(X[0].(Node).place) {
					// expression is of the form 1+b, which is to be converted to b+1
					n.place = NewTmp()
					n.code = append(n.code, fmt.Sprintf("+, %s, %s, %s", n.place, X[2].(Node).place, X[0].(Node).place))
					n.code = append(n.code, "\n")
				} else {
					n.place = NewTmp()
					n.code = append(n.code, fmt.Sprintf("+, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
					n.code = append(n.code, "\n")
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term3 : Term4	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Term3",
		NTType:     17,
		Index:      30,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term4 : Term4 "-" Term5	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("-, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>`,
		Id:         "Term4",
		NTType:     18,
		Index:      31,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				n.place = NewTmp()
				n.code = append(n.code, fmt.Sprintf("-, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
				n.code = append(n.code, "\n")
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term4 : Term5	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Term4",
		NTType:     18,
		Index:      32,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term5 : Term5 "*" Term6	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("*, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>`,
		Id:         "Term5",
		NTType:     19,
		Index:      33,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				n.place = NewTmp()
				n.code = append(n.code, fmt.Sprintf("*, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
				n.code = append(n.code, "\n")
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term5 : Term6	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Term5",
		NTType:     19,
		Index:      34,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term6 : Term6 "/" Term7	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("/, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>`,
		Id:         "Term6",
		NTType:     20,
		Index:      35,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				n.place = NewTmp()
				n.code = append(n.code, fmt.Sprintf("/, %s, %s, %s", n.place, X[0].(Node).place, X[2].(Node).place))
				n.code = append(n.code, "\n")
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term6 : Term7	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Term6",
		NTType:     20,
		Index:      36,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term7 : "(" Expression ")"	<< func() (Attrib, error) {
                        return Node{X[1].(Node).place, X[1].(Node).code}, nil
                } () >>`,
		Id:         "Term7",
		NTType:     21,
		Index:      37,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[1].(Node).place, X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Term7 : UnaryExpr	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Term7",
		NTType:     21,
		Index:      38,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `BinaryOp : RelOp	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, []string{}}, nil
                } () >>`,
		Id:         "BinaryOp",
		NTType:     22,
		Index:      39,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `BinaryOp : "||"	<< func() (Attrib, error) {
                        return Node{"or", []string{}}, nil
                } () >>`,
		Id:         "BinaryOp",
		NTType:     22,
		Index:      40,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"or", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `BinaryOp : "&&"	<< func() (Attrib, error) {
                        return Node{"and", []string{}}, nil
                } () >>`,
		Id:         "BinaryOp",
		NTType:     22,
		Index:      41,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"and", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RelOp : "=="	<< func() (Attrib, error) {
                return Node{"==", []string{}}, nil
        } () >>`,
		Id:         "RelOp",
		NTType:     23,
		Index:      42,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"==", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RelOp : "!="	<< func() (Attrib, error) {
                return Node{"!=", []string{}}, nil
        } () >>`,
		Id:         "RelOp",
		NTType:     23,
		Index:      43,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"!=", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RelOp : "<="	<< func() (Attrib, error) {
                return Node{"<=", []string{}}, nil
        } () >>`,
		Id:         "RelOp",
		NTType:     23,
		Index:      44,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"<=", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RelOp : "<"	<< func() (Attrib, error) {
                return Node{"<", []string{}}, nil
        } () >>`,
		Id:         "RelOp",
		NTType:     23,
		Index:      45,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"<", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RelOp : ">="	<< func() (Attrib, error) {
                return Node{">=", []string{}}, nil
        } () >>`,
		Id:         "RelOp",
		NTType:     23,
		Index:      46,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{">=", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RelOp : ">"	<< func() (Attrib, error) {
                return Node{">", []string{}}, nil
        } () >>`,
		Id:         "RelOp",
		NTType:     23,
		Index:      47,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{">", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `UnaryExpr : PrimaryExpr	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "UnaryExpr",
		NTType:     24,
		Index:      48,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `UnaryExpr : UnaryOp UnaryExpr	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        n.code = append(n.code, X[1].(Node).code...)
                        switch X[0].(Node).place {
                        case "-":
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("*, %s, %s, -1", n.place, X[1].(Node).place))
                        case "!":
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("not, %s, %s", n.place, X[1].(Node).place))
                        case "+":
                                n.place = X[1].(Node).place
                        case "&":
                                // Place of any pointer variable starts with "pointer:" and then followed by string returned by NewTmp()
                                n.place = "pointer:" + X[1].(Node).place
                        case "*":
                                n.place = "deref:" + X[1].(Node).place
                        default:
                                return n, errors.New(fmt.Sprintf("%s operator not supported", X[0].(Node).place))
                        }
                        return n, nil
                } () >>`,
		Id:         "UnaryExpr",
		NTType:     24,
		Index:      49,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				n.code = append(n.code, X[1].(Node).code...)
				switch X[0].(Node).place {
				case "-":
					n.place = NewTmp()
					n.code = append(n.code, fmt.Sprintf("*, %s, %s, -1", n.place, X[1].(Node).place))
				case "!":
					n.place = NewTmp()
					n.code = append(n.code, fmt.Sprintf("not, %s, %s", n.place, X[1].(Node).place))
				case "+":
					n.place = X[1].(Node).place
				case "&":
					// Place of any pointer variable starts with "pointer:" and then followed by string returned by NewTmp()
					n.place = "pointer:" + X[1].(Node).place
				case "*":
					n.place = "deref:" + X[1].(Node).place
				default:
					return n, errors.New(fmt.Sprintf("%s operator not supported", X[0].(Node).place))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `UnaryOp : "+"	<< func() (Attrib, error) {
                    return Node{"+", []string{}}, nil
              } () >>`,
		Id:         "UnaryOp",
		NTType:     25,
		Index:      50,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"+", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `UnaryOp : "-"	<< func() (Attrib, error) {
                    return Node{"-", []string{}}, nil
              } () >>`,
		Id:         "UnaryOp",
		NTType:     25,
		Index:      51,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"-", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `UnaryOp : "!"	<< func() (Attrib, error) {
                    return Node{"!", []string{}}, nil
              } () >>`,
		Id:         "UnaryOp",
		NTType:     25,
		Index:      52,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"!", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `UnaryOp : "*"	<< func() (Attrib, error) {
                   return Node{"*", []string{}}, nil
             } () >>`,
		Id:         "UnaryOp",
		NTType:     25,
		Index:      53,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"*", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `UnaryOp : "&"	<< func() (Attrib, error) {
                   return Node{"&", []string{}}, nil
             } () >>`,
		Id:         "UnaryOp",
		NTType:     25,
		Index:      54,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"&", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `PrimaryExpr : Operand	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "PrimaryExpr",
		NTType:     26,
		Index:      55,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `PrimaryExpr : PrimaryExpr Selector	<< func() (Attrib, error) {
                          varName := fmt.Sprintf("%s.%s", X[0].(Node).place, X[1].(Node).place)
                          symTabEntry, found := SearchInScope(varName)
                          if found {
                                if _, ok := globalSymTab[varName]; ok {
                                            return nil, errors.New(fmt.Sprintf("%s not in scope", varName) )
                                   } else {
                                            return Node{symTabEntry[0], []string{}}, nil
                                   }
                          } else {
                                 return nil, errors.New(fmt.Sprintf("%s not in scope", varName) )
                          }
                    } () >>`,
		Id:         "PrimaryExpr",
		NTType:     26,
		Index:      56,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				varName := fmt.Sprintf("%s.%s", X[0].(Node).place, X[1].(Node).place)
				symTabEntry, found := SearchInScope(varName)
				if found {
					if _, ok := globalSymTab[varName]; ok {
						return nil, errors.New(fmt.Sprintf("%s not in scope", varName))
					} else {
						return Node{symTabEntry[0], []string{}}, nil
					}
				} else {
					return nil, errors.New(fmt.Sprintf("%s not in scope", varName))
				}
			}()
		},
	},
	ProdTabEntry{
		String: `PrimaryExpr : PrimaryExpr Index	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        n.place = NewTmp()
                        // TODO: Write comment here.
                        symTab[n.place] = []string{fmt.Sprintf("%s, %s", X[0].(Node).place, X[1].(Node).place), "array"}
                        n.code = append(n.code, X[1].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("from, %s, %s, %s", n.place, X[0].(Node).place, X[1].(Node).place))
                        return n, nil
                } () >>`,
		Id:         "PrimaryExpr",
		NTType:     26,
		Index:      57,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				n.place = NewTmp()
				// TODO: Write comment here.
				symTab[n.place] = []string{fmt.Sprintf("%s, %s", X[0].(Node).place, X[1].(Node).place), "array"}
				n.code = append(n.code, X[1].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("from, %s, %s, %s", n.place, X[0].(Node).place, X[1].(Node).place))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `PrimaryExpr : PrimaryExpr Arguments	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        typeName := globalSymTab[X[0].(Node).place][0]
                        var returnLength int
                        if len(typeName) >= 5 && typeName[:4] == "func" {
                                returnLength, _ = strconv.Atoi(typeName[5:])
                        } else {
                                return nil, errors.New(fmt.Sprintf("%s not a function", X[0].(Node).place))
                        }
                        argExpr := utils.SplitAndSanitize(X[1].(Node).place, ",")
                        for k, v := range argExpr {
                              n.code = append(n.code, fmt.Sprintf("=, %s.%d, %s", X[0].(Node).place, k, v))
                        }
                        n.code = append(n.code, fmt.Sprintf("call, %s", X[0].(Node).place))
                        for k:=0 ; k < returnLength ; k++ {
                                n.place = fmt.Sprintf("%s, return.%d", n.place, k)
                        }

                        // n.code = append(n.code, fmt.Sprintf("store, %s", n.place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>`,
		Id:         "PrimaryExpr",
		NTType:     26,
		Index:      58,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				typeName := globalSymTab[X[0].(Node).place][0]
				var returnLength int
				if len(typeName) >= 5 && typeName[:4] == "func" {
					returnLength, _ = strconv.Atoi(typeName[5:])
				} else {
					return nil, errors.New(fmt.Sprintf("%s not a function", X[0].(Node).place))
				}
				argExpr := utils.SplitAndSanitize(X[1].(Node).place, ",")
				for k, v := range argExpr {
					n.code = append(n.code, fmt.Sprintf("=, %s.%d, %s", X[0].(Node).place, k, v))
				}
				n.code = append(n.code, fmt.Sprintf("call, %s", X[0].(Node).place))
				for k := 0; k < returnLength; k++ {
					n.place = fmt.Sprintf("%s, return.%d", n.place, k)
				}

				// n.code = append(n.code, fmt.Sprintf("store, %s", n.place))
				n.code = append(n.code, "\n")
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Operand : Literal	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Operand",
		NTType:     27,
		Index:      59,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Operand : OperandName	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, []string{}}, nil
                } () >>`,
		Id:         "Operand",
		NTType:     27,
		Index:      60,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Literal : BasicLit	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, []string{}}, nil
                } () >>`,
		Id:         "Literal",
		NTType:     28,
		Index:      61,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Literal : CompositeLit	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Literal",
		NTType:     28,
		Index:      62,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `BasicLit : intLit	<< func() (Attrib, error) {
                        return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
                } () >>`,
		Id:         "BasicLit",
		NTType:     29,
		Index:      63,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `CompositeLit : LiteralType LiteralValue	<< func() (Attrib, error) {
                                // NOTE: Structs don't support initialization of members
                                // currently. All data members are initialized to default
                                // values when a struct instance is defined.
                                n := Node{X[0].(Node).place, []string{}}
                                // Check if the LiteralType corresponds to ArrayType.
                                // This is done because unlike structs it is not required
                                // to add a symbol table entry for place value of arrays
                                // (which is of the form "array:<length_of_array>"), thus
                                // returning early.
                                typeName := X[0].(Node).place
                                if len(typeName) >= 5 && typeName[:5] == "array" {
                                        return n, nil
                                }
                                // In case the corresponds to a struct, add the
                                // code for its data member initialization.
                                symTabEntry, found := SearchInScope(X[0].(Node).place)
                                if found {
                                        switch symTabEntry[0] {
                                        case "struct":
                                                // The place value for struct is of the form -
                                                //      struct:<number of members of struct>:<name of struct>
                                                n.place = fmt.Sprintf("struct:%d:%s", (len(symTabEntry)-1) / 2, n.place)
                                                litVals := utils.SplitAndSanitize(X[1].(Node).place, ",")
                                                litValCodes := X[1].(Node).code
                                                structInit := []string{}
                                                // In case of integral (or any type) initializations, the corresponding
                                                // lexeme is placed at the place value, justifying the length check which
                                                // is made on 'litVals' instead of 'litValCodes'. If there are no place
                                                // values for the data members, then initialize all to their default
                                                // values. Otherwise initialize them to the corresponding place value.
                                                if len(litVals) == 0 {
                                                        for k, v := range symTabEntry[1:] {
                                                                if k % 2 == 0 {
                                                                        structInit = append(structInit, v)
                                                                        // TODO: Update default values depending on type
                                                                        structInit = append(structInit, "0")
                                                                }
                                                        }
                                                } else {
                                                        for k, v := range symTabEntry[1:] {
                                                                if k % 2 == 0 {
                                                                        structInit = append(structInit, v)
                                                                        structInit = append(structInit, litVals[k / 2])
                                                                }
                                                        }
                                                }
                                                // When these code values will be utilized above, the litValCodes will be
                                                // placed above the code corresponding to structInit (litVals can be expressions).
                                                n.code = append(n.code, structInit...)
                                                n.code = append(n.code, litValCodes...)
                                        }
                                } else {
                                        // TODO: Update error message.
                                        return nil, errors.New(fmt.Sprintf("%s not in scope", X[0].(Node).place))
                                }
                                return n, nil
                        } () >>`,
		Id:         "CompositeLit",
		NTType:     30,
		Index:      64,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// NOTE: Structs don't support initialization of members
				// currently. All data members are initialized to default
				// values when a struct instance is defined.
				n := Node{X[0].(Node).place, []string{}}
				// Check if the LiteralType corresponds to ArrayType.
				// This is done because unlike structs it is not required
				// to add a symbol table entry for place value of arrays
				// (which is of the form "array:<length_of_array>"), thus
				// returning early.
				typeName := X[0].(Node).place
				if len(typeName) >= 5 && typeName[:5] == "array" {
					return n, nil
				}
				// In case the corresponds to a struct, add the
				// code for its data member initialization.
				symTabEntry, found := SearchInScope(X[0].(Node).place)
				if found {
					switch symTabEntry[0] {
					case "struct":
						// The place value for struct is of the form -
						//      struct:<number of members of struct>:<name of struct>
						n.place = fmt.Sprintf("struct:%d:%s", (len(symTabEntry)-1)/2, n.place)
						litVals := utils.SplitAndSanitize(X[1].(Node).place, ",")
						litValCodes := X[1].(Node).code
						structInit := []string{}
						// In case of integral (or any type) initializations, the corresponding
						// lexeme is placed at the place value, justifying the length check which
						// is made on 'litVals' instead of 'litValCodes'. If there are no place
						// values for the data members, then initialize all to their default
						// values. Otherwise initialize them to the corresponding place value.
						if len(litVals) == 0 {
							for k, v := range symTabEntry[1:] {
								if k%2 == 0 {
									structInit = append(structInit, v)
									// TODO: Update default values depending on type
									structInit = append(structInit, "0")
								}
							}
						} else {
							for k, v := range symTabEntry[1:] {
								if k%2 == 0 {
									structInit = append(structInit, v)
									structInit = append(structInit, litVals[k/2])
								}
							}
						}
						// When these code values will be utilized above, the litValCodes will be
						// placed above the code corresponding to structInit (litVals can be expressions).
						n.code = append(n.code, structInit...)
						n.code = append(n.code, litValCodes...)
					}
				} else {
					// TODO: Update error message.
					return nil, errors.New(fmt.Sprintf("%s not in scope", X[0].(Node).place))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `LiteralType : ArrayType	<< func() (Attrib, error) {
                                return Node{X[0].(Node).place, []string{}}, nil
                        } () >>`,
		Id:         "LiteralType",
		NTType:     31,
		Index:      65,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `LiteralType : TypeName	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "LiteralType",
		NTType:     31,
		Index:      66,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `TypeName : identifier	<< func() (Attrib, error) {
                        return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
                } () >>`,
		Id:         "TypeName",
		NTType:     32,
		Index:      67,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `LiteralValue : "{" RepeatTerminator "}"	<< func() (Attrib, error) {
                                return Node{"", []string{}}, nil
                        } () >>`,
		Id:         "LiteralValue",
		NTType:     33,
		Index:      68,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `LiteralValue : "{" RepeatTerminator ElementList "}"	<< func() (Attrib, error) {
                                return Node{X[2].(Node).place, X[2].(Node).code}, nil
                        } () >>`,
		Id:         "LiteralValue",
		NTType:     33,
		Index:      69,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[2].(Node).place, X[2].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ElementList : KeyedElement RepeatKeyedElement	<< func() (Attrib, error) {
                        n := Node{fmt.Sprintf("%s, %s", X[0].(Node).place, X[1].(Node).place), X[0].(Node).code}
                        n.code = append(n.code, X[1].(Node).code...)
                        return n, nil
                } () >>`,
		Id:         "ElementList",
		NTType:     34,
		Index:      70,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{fmt.Sprintf("%s, %s", X[0].(Node).place, X[1].(Node).place), X[0].(Node).code}
				n.code = append(n.code, X[1].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatKeyedElement : "," RepeatTerminator KeyedElement RepeatKeyedElement	<< func() (Attrib, error) {
                                n := Node{fmt.Sprintf("%s, %s", X[2].(Node).place, X[3].(Node).place), X[2].(Node).code}
                                n.code = append(n.code, X[3].(Node).code...)
                                return n, nil
                        } () >>`,
		Id:         "RepeatKeyedElement",
		NTType:     35,
		Index:      71,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{fmt.Sprintf("%s, %s", X[2].(Node).place, X[3].(Node).place), X[2].(Node).code}
				n.code = append(n.code, X[3].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatKeyedElement : RepeatTerminator	<< func() (Attrib, error) {
                                return Node{"", []string{}}, nil
                        } () >>`,
		Id:         "RepeatKeyedElement",
		NTType:     35,
		Index:      72,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `KeyedElement : Element	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "KeyedElement",
		NTType:     36,
		Index:      73,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Element : Expression	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Element",
		NTType:     37,
		Index:      74,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `OperandName : identifier	<< func() (Attrib, error) {
                        // return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
                        varName := string(X[0].(*token.Token).Lit)
                        symTabEntry, found := SearchInScope(varName)
                        if found {
                        	if _, ok := globalSymTab[varName]; ok {
                        		return Node{varName, []string{}}, nil
                        	} else {
                                        return Node{symTabEntry[0], []string{}}, nil
                        	}
                        } else {
                        	return nil, errors.New(fmt.Sprintf("%s not declared", varName))
                        }
                } () >>`,
		Id:         "OperandName",
		NTType:     38,
		Index:      75,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
				varName := string(X[0].(*token.Token).Lit)
				symTabEntry, found := SearchInScope(varName)
				if found {
					if _, ok := globalSymTab[varName]; ok {
						return Node{varName, []string{}}, nil
					} else {
						return Node{symTabEntry[0], []string{}}, nil
					}
				} else {
					return nil, errors.New(fmt.Sprintf("%s not declared", varName))
				}
			}()
		},
	},
	ProdTabEntry{
		String: `Selector : "." identifier	<< func() (Attrib, error) {
                        return Node{string(X[1].(*token.Token).Lit), []string{}}, nil
                } () >>`,
		Id:         "Selector",
		NTType:     39,
		Index:      76,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{string(X[1].(*token.Token).Lit), []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Index : "[" Expression "]"	<< func() (Attrib, error) {
                        return Node{X[1].(Node).place, X[1].(Node).code}, nil
                } () >>`,
		Id:         "Index",
		NTType:     40,
		Index:      77,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[1].(Node).place, X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Arguments : "(" ")"	<< func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>`,
		Id:         "Arguments",
		NTType:     41,
		Index:      78,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Arguments : "(" ExpressionList ")"	<< func() (Attrib, error) {
                      return Node{X[1].(Node).place, X[1].(Node).code}, nil
                } () >>`,
		Id:         "Arguments",
		NTType:     41,
		Index:      79,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[1].(Node).place, X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `FunctionDecl : FunctionMarker FunctionBody	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[1].(Node).code...)
                        funcSymtabCreated = false // end of function block
                        // Return statement insertion will be handled when defer
                        // stack is emptied and the deferred calls are inserted.
                        addRetStmt := false
                        if deferStack.Len > 0 {
                                addRetStmt = true
                        }
                        for deferStack.Len > 0 {
                                deferFuncCode := deferStack.Pop().(DeferStackItem)
                                n.code = append(n.code, deferFuncCode...)
                        }
                        if addRetStmt {
                                n.code = append(n.code, fmt.Sprintf("ret,"))
                        }
                        return n, nil
                } () >>`,
		Id:         "FunctionDecl",
		NTType:     42,
		Index:      80,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[1].(Node).code...)
				funcSymtabCreated = false // end of function block
				// Return statement insertion will be handled when defer
				// stack is emptied and the deferred calls are inserted.
				addRetStmt := false
				if deferStack.Len > 0 {
					addRetStmt = true
				}
				for deferStack.Len > 0 {
					deferFuncCode := deferStack.Pop().(DeferStackItem)
					n.code = append(n.code, deferFuncCode...)
				}
				if addRetStmt {
					n.code = append(n.code, fmt.Sprintf("ret,"))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `FunctionMarker : kwdFunc FunctionName Signature	<< func() (Attrib, error) {
                        n := Node{X[1].(Node).place, []string{fmt.Sprintf("func, %s", X[1].(Node).place)}}
                        // Assign values to arguments.
                        for k, v := range X[2].(Node).code {
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s.%d", v, X[1].(Node).place, k))
                        }
                        if _, found := globalSymTab[X[1].(Node).place]; !found {
                                globalSymTab[X[1].(Node).place] = []string{fmt.Sprintf("func:%s", X[2].(Node).place)}
                        } else {
                                return nil, errors.New(fmt.Sprintf("Function %s already declared\n", string(X[0].(*token.Token).Lit)))
                        }
                        return n, nil
                } () >>`,
		Id:         "FunctionMarker",
		NTType:     43,
		Index:      81,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{X[1].(Node).place, []string{fmt.Sprintf("func, %s", X[1].(Node).place)}}
				// Assign values to arguments.
				for k, v := range X[2].(Node).code {
					n.code = append(n.code, fmt.Sprintf("=, %s, %s.%d", v, X[1].(Node).place, k))
				}
				if _, found := globalSymTab[X[1].(Node).place]; !found {
					globalSymTab[X[1].(Node).place] = []string{fmt.Sprintf("func:%s", X[2].(Node).place)}
				} else {
					return nil, errors.New(fmt.Sprintf("Function %s already declared\n", string(X[0].(*token.Token).Lit)))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Signature : Parameters	<< func() (Attrib, error) {
                      // The parent symbol table in case of function declaration
                      // will be nil as functions can only be declared globally.
                      childSymTab := SymInfo{make(symTabType), currSymTab}
                      // Update the current symbol table to point to the newly
                      // created symbol table.
                      currSymTab = &childSymTab
                      for _, v := range X[0].(Node).code {
                            if v == "" {
                                  break
                            }
                            currSymTab.varSymTab[v] = []string{v, "int"}
                      }
                      return Node{"0", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Signature",
		NTType:     44,
		Index:      82,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// The parent symbol table in case of function declaration
				// will be nil as functions can only be declared globally.
				childSymTab := SymInfo{make(symTabType), currSymTab}
				// Update the current symbol table to point to the newly
				// created symbol table.
				currSymTab = &childSymTab
				for _, v := range X[0].(Node).code {
					if v == "" {
						break
					}
					currSymTab.varSymTab[v] = []string{v, "int"}
				}
				return Node{"0", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Signature : Parameters Result	<< func() (Attrib, error) {
                       // The parent symbol table in case of function declaration
                       // will be nil as functions can only be declared globally.
                       childSymTab := SymInfo{make(symTabType), currSymTab}
                       // Update the current symbol table to point to the newly
                       // created symbol table.
                       currSymTab = &childSymTab
                       for _, v := range X[0].(Node).code {
                             if v == "" {
                                   break
                             }
                             currSymTab.varSymTab[v] = []string{v, "int"}
                       }
                       return Node{fmt.Sprintf("%s", X[1].(Node).place), X[0].(Node).code}, nil
                 } () >>`,
		Id:         "Signature",
		NTType:     44,
		Index:      83,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// The parent symbol table in case of function declaration
				// will be nil as functions can only be declared globally.
				childSymTab := SymInfo{make(symTabType), currSymTab}
				// Update the current symbol table to point to the newly
				// created symbol table.
				currSymTab = &childSymTab
				for _, v := range X[0].(Node).code {
					if v == "" {
						break
					}
					currSymTab.varSymTab[v] = []string{v, "int"}
				}
				return Node{fmt.Sprintf("%s", X[1].(Node).place), X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Result : Parameters	<< func() (Attrib, error) {
                    returnLength := 0
                    // finding number of return variable
                    for _, v := range X[0].(Node).code {
                            if v == "int" {
                                    returnLength ++
                            }
                    }
                    return Node{fmt.Sprintf("%d", returnLength), []string{}}, nil
              } () >>`,
		Id:         "Result",
		NTType:     45,
		Index:      84,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				returnLength := 0
				// finding number of return variable
				for _, v := range X[0].(Node).code {
					if v == "int" {
						returnLength++
					}
				}
				return Node{fmt.Sprintf("%d", returnLength), []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Result : Type	<< func() (Attrib, error) {
                    return Node{"1", []string{}}, nil
              } () >>`,
		Id:         "Result",
		NTType:     45,
		Index:      85,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"1", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Parameters : "(" RepeatTerminator ")"	<< func() (Attrib, error) {
                      return Node{"", []string{}}, nil
                } () >>`,
		Id:         "Parameters",
		NTType:     46,
		Index:      86,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Parameters : "(" ParameterList ")"	<< func() (Attrib, error) {
                      return Node{"", X[1].(Node).code}, nil
                } () >>`,
		Id:         "Parameters",
		NTType:     46,
		Index:      87,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ParameterList : ParameterDecl RepeatParameterDecl	<< func() (Attrib, error) {
                      n := Node{"", X[0].(Node).code}
                      n.code = append(n.code, X[1].(Node).code...)
                      return n, nil
                } () >>`,
		Id:         "ParameterList",
		NTType:     47,
		Index:      88,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[1].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatParameterDecl : "," ParameterDecl RepeatParameterDecl	<< func() (Attrib, error) {
                              n := Node{"", X[1].(Node).code}
                              n.code = append(n.code, X[2].(Node).code...)
                              return n, nil
                        } () >>`,
		Id:         "RepeatParameterDecl",
		NTType:     48,
		Index:      89,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatParameterDecl : empty	<< func() (Attrib, error) {
                              return Node{"", []string{}}, nil
                        } () >>`,
		Id:         "RepeatParameterDecl",
		NTType:     48,
		Index:      90,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ParameterDecl : IdentifierList Type	<< func() (Attrib, error) {
                      return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "ParameterDecl",
		NTType:     49,
		Index:      91,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ParameterDecl : Type	<< func() (Attrib, error) {
                      return Node{"", []string{fmt.Sprintf("int")}}, nil
                } () >>`,
		Id:         "ParameterDecl",
		NTType:     49,
		Index:      92,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{fmt.Sprintf("int")}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Type : type	<< func() (Attrib, error) {
                typeLit := string(X[0].(*token.Token).Lit)
                if typeLit != "int" || typeLit != "float32" {
                        return nil, errors.New(fmt.Sprintf("Unsupported type: %s", typeLit))
                }
                return Node{typeLit, []string{}}, nil
        } () >>`,
		Id:         "Type",
		NTType:     50,
		Index:      93,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				typeLit := string(X[0].(*token.Token).Lit)
				if typeLit != "int" || typeLit != "float32" {
					return nil, errors.New(fmt.Sprintf("Unsupported type: %s", typeLit))
				}
				return Node{typeLit, []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Type : TypeLit	<< func() (Attrib, error) {
              return Node{X[0].(Node).place, X[0].(Node).code}, nil
        } () >>`,
		Id:         "Type",
		NTType:     50,
		Index:      94,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `TypeLit : StructType	<< func() (Attrib, error) {
                        return Node{"struct", X[0].(Node).code}, nil
                } () >>`,
		Id:         "TypeLit",
		NTType:     51,
		Index:      95,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"struct", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ArrayType : "[" ArrayLength "]" ElementType	<< func() (Attrib, error) {
                        // TODO: ElementType is taken to be only int for now.
                        return Node{fmt.Sprintf("array:%s", X[1].(Node).place), []string{}}, nil
                } () >>`,
		Id:         "ArrayType",
		NTType:     52,
		Index:      96,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// TODO: ElementType is taken to be only int for now.
				return Node{fmt.Sprintf("array:%s", X[1].(Node).place), []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ArrayLength : intLit	<< func() (Attrib, error) {
                        return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
                } () >>`,
		Id:         "ArrayLength",
		NTType:     53,
		Index:      97,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ElementType : Type	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, []string{}}, nil
                } () >>`,
		Id:         "ElementType",
		NTType:     54,
		Index:      98,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `StructType : kwdStruct RepeatTerminator "{" RepeatTerminator RepeatFieldDecl "}"	<< func() (Attrib, error) {
                        return Node{"", X[4].(Node).code}, nil
                } () >>`,
		Id:         "StructType",
		NTType:     55,
		Index:      99,
		NumSymbols: 6,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[4].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatFieldDecl : FieldDecl terminator RepeatTerminator RepeatFieldDecl	<< func() (Attrib, error) {
                                n := Node{"", X[0].(Node).code}
                                n.code = append(n.code, X[3].(Node).code...)
                                return n, nil
                        } () >>`,
		Id:         "RepeatFieldDecl",
		NTType:     56,
		Index:      100,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[3].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatFieldDecl : FieldDecl RepeatTerminator	<< func() (Attrib, error) {
                                return Node{"", X[0].(Node).code}, nil
                        } () >>`,
		Id:         "RepeatFieldDecl",
		NTType:     56,
		Index:      101,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `FieldDecl : IdentifierList Type	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range X[0].(Node).code {
                                n.code = append(n.code, v)
                                n.code = append(n.code, X[1].(Node).place)
                        }
                        return n, nil
                } () >>`,
		Id:         "FieldDecl",
		NTType:     57,
		Index:      102,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				for _, v := range X[0].(Node).code {
					n.code = append(n.code, v)
					n.code = append(n.code, X[1].(Node).place)
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `FieldDecl : empty	<< func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>`,
		Id:         "FieldDecl",
		NTType:     57,
		Index:      103,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IdentifierList : identifier	<< func() (Attrib, error) {
                                return Node{"", []string{string(X[0].(*token.Token).Lit)}}, nil
                        } () >>`,
		Id:         "IdentifierList",
		NTType:     58,
		Index:      104,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{string(X[0].(*token.Token).Lit)}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IdentifierList : identifier "," IdentifierList	<< func() (Attrib, error) {
                                // The lexemes corresponding to the individual identifiers
                                // are appended to the slice for code to avoid adding
                                // comma-separated string in place since the identifiers
                                // don't have any IR code to be added.
                                n := Node{"", []string{string(X[0].(*token.Token).Lit)}}
                                n.code = append(n.code, X[2].(Node).code...)
                                return n, nil
                        } () >>`,
		Id:         "IdentifierList",
		NTType:     58,
		Index:      105,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// The lexemes corresponding to the individual identifiers
				// are appended to the slice for code to avoid adding
				// comma-separated string in place since the identifiers
				// don't have any IR code to be added.
				n := Node{"", []string{string(X[0].(*token.Token).Lit)}}
				n.code = append(n.code, X[2].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `FunctionName : identifier	<< func() (Attrib, error) {
                        // The symbol table entry for a function is of the form -
                        //      functionName : ["func", (rest of the values are yet to be decided)]

                        return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
                 } () >>`,
		Id:         "FunctionName",
		NTType:     59,
		Index:      106,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// The symbol table entry for a function is of the form -
				//      functionName : ["func", (rest of the values are yet to be decided)]

				return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `FunctionBody : Block	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "FunctionBody",
		NTType:     60,
		Index:      107,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatTerminator : terminator RepeatTerminator	<<  >>`,
		Id:         "RepeatTerminator",
		NTType:     61,
		Index:      108,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `RepeatTerminator : empty	<<  >>`,
		Id:         "RepeatTerminator",
		NTType:     61,
		Index:      109,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `StatementList : Statement terminator RepeatTerminator StatementList	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[3].(Node).code...)
                        return n, nil
                } () >>`,
		Id:         "StatementList",
		NTType:     62,
		Index:      110,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[3].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `StatementList : Statement RepeatTerminator	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "StatementList",
		NTType:     62,
		Index:      111,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : Declaration	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      112,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : LabeledStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      113,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : SimpleStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      114,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : ReturnStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      115,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : BreakStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      116,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : ContinueStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      117,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : GotoStmt	<< func() (Attrib, error) {
                       return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      118,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : Block	<< func() (Attrib, error) {
                       return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      119,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : IfStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      120,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : SwitchStmt	<< func() (Attrib, error) {
                       return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      121,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : ForStmt	<< func() (Attrib, error) {
                       return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      122,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : DeferStmt	<< func() (Attrib, error) {
                       return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      123,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Statement : PrintIntStmt	<< func() (Attrib, error) {
                       return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "Statement",
		NTType:     63,
		Index:      124,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `LabeledStmt : Label ":" RepeatTerminator Statement	<< func() (Attrib, error) {
                        n := Node{"", []string{fmt.Sprintf("label, %s", X[0].(Node).place)}}
                        n.code = append(n.code, X[3].(Node).code...)
                        return n, nil
                } () >>`,
		Id:         "LabeledStmt",
		NTType:     64,
		Index:      125,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{fmt.Sprintf("label, %s", X[0].(Node).place)}}
				n.code = append(n.code, X[3].(Node).code...)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `SimpleStmt : EmptyStmt	<< func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>`,
		Id:         "SimpleStmt",
		NTType:     65,
		Index:      126,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `SimpleStmt : Assignment	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "SimpleStmt",
		NTType:     65,
		Index:      127,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `SimpleStmt : ShortVarDecl	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "SimpleStmt",
		NTType:     65,
		Index:      128,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `SimpleStmt : IncDecStmt	<< func() (Attrib, error) {
                       return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "SimpleStmt",
		NTType:     65,
		Index:      129,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `EmptyStmt : empty	<<  >>`,
		Id:         "EmptyStmt",
		NTType:     66,
		Index:      130,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `ReturnStmt : kwdRet	<< func() (Attrib, error) {
                        // The defer statements need to be inserted before the return stmt (and
                        // not at the end of function block as was the previous misconception).
                        // When defer stmt is used, the return stmt for main() is also inserted
                        // when all the defer calls from stack are popped and inserted in IR.
                        if deferStack.Len > 0 {
                                // Return statement insertion will be handled when defer
                                // stack is emptied and the deferred calls are inserted.
                                return Node{"", []string{}}, nil
                        } else {
                                return Node{"", []string{"ret,"}}, nil
                        }
                } () >>`,
		Id:         "ReturnStmt",
		NTType:     67,
		Index:      131,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// The defer statements need to be inserted before the return stmt (and
				// not at the end of function block as was the previous misconception).
				// When defer stmt is used, the return stmt for main() is also inserted
				// when all the defer calls from stack are popped and inserted in IR.
				if deferStack.Len > 0 {
					// Return statement insertion will be handled when defer
					// stack is emptied and the deferred calls are inserted.
					return Node{"", []string{}}, nil
				} else {
					return Node{"", []string{"ret,"}}, nil
				}
			}()
		},
	},
	ProdTabEntry{
		String: `ReturnStmt : kwdRet ExpressionList	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        if deferStack.Len == 0 {
                                retExpr := utils.SplitAndSanitize(X[1].(Node).place, ",")
                                n.code = append(n.code, X[1].(Node).code...)
                                for k, v := range retExpr {
                                      n.code = append(n.code, fmt.Sprintf("=, return.%d, %s", k, v))
                                }
                                n.code = append(n.code, fmt.Sprintf("ret,"))
                        }
                        return n, nil
                } () >>`,
		Id:         "ReturnStmt",
		NTType:     67,
		Index:      132,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				if deferStack.Len == 0 {
					retExpr := utils.SplitAndSanitize(X[1].(Node).place, ",")
					n.code = append(n.code, X[1].(Node).code...)
					for k, v := range retExpr {
						n.code = append(n.code, fmt.Sprintf("=, return.%d, %s", k, v))
					}
					n.code = append(n.code, fmt.Sprintf("ret,"))
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `BreakStmt : kwdBreak	<< func() (Attrib, error) {
                        return Node{"", []string{"break"}}, nil
                } () >>`,
		Id:         "BreakStmt",
		NTType:     68,
		Index:      133,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{"break"}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `BreakStmt : kwdBreak Label	<< func() (Attrib, error) {
                        return Node{"", []string{fmt.Sprintf("j, %s", X[1].(Node).place)}}, nil
                } () >>`,
		Id:         "BreakStmt",
		NTType:     68,
		Index:      134,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{fmt.Sprintf("j, %s", X[1].(Node).place)}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ContinueStmt : kwdContinue	<< func() (Attrib, error) {
                        return Node{"", []string{"continue"}}, nil
                } () >>`,
		Id:         "ContinueStmt",
		NTType:     69,
		Index:      135,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{"continue"}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `GotoStmt : kwdGoto Label	<< func() (Attrib, error) {
                        return Node{"", []string{fmt.Sprintf("j, %s", X[1].(Node).place)}}, nil
                } () >>`,
		Id:         "GotoStmt",
		NTType:     70,
		Index:      136,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{fmt.Sprintf("j, %s", X[1].(Node).place)}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Block : "{" Marker RepeatTerminator StatementList "}"	<< func() (Attrib, error) {
                        // start of block
                        if  currSymTab.parent != nil {
                                currSymTab = currSymTab.parent // end of block
                        } else {
                                currSymTab = nil
                        }
                        return Node{"", X[3].(Node).code}, nil
                } () >>`,
		Id:         "Block",
		NTType:     71,
		Index:      137,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// start of block
				if currSymTab.parent != nil {
					currSymTab = currSymTab.parent // end of block
				} else {
					currSymTab = nil
				}
				return Node{"", X[3].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Marker : empty	<< func() (Attrib, error) {
                        if funcSymtabCreated {
                                // The symbol table for functions is created when the
                                // rule for Signature is reached so that the arguments
                                // can also be added. At this point the function block
                                // (if there was any) has completed.
                                childSymTab := SymInfo{make(symTabType), currSymTab}
                                // Update the current symbol table to point to the newly
                                // created symbol table.
                                currSymTab = &childSymTab
                        } else {
                                // Allow creation of symbol table for another function.
                                funcSymtabCreated = true
                        }
                        return nil, nil
                } () >>`,
		Id:         "Marker",
		NTType:     72,
		Index:      138,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				if funcSymtabCreated {
					// The symbol table for functions is created when the
					// rule for Signature is reached so that the arguments
					// can also be added. At this point the function block
					// (if there was any) has completed.
					childSymTab := SymInfo{make(symTabType), currSymTab}
					// Update the current symbol table to point to the newly
					// created symbol table.
					currSymTab = &childSymTab
				} else {
					// Allow creation of symbol table for another function.
					funcSymtabCreated = true
				}
				return nil, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IfStmt : kwdIf Expression Block	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[1].(Node).place))
                        n.code = append(n.code, X[2].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>`,
		Id:         "IfStmt",
		NTType:     73,
		Index:      139,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				afterLabel := NewLabel()
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[1].(Node).place))
				n.code = append(n.code, X[2].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				n.code = append(n.code, "\n")
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IfStmt : kwdIf Expression Block kwdElse Block	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[1].(Node).place))
                        n.code = append(n.code, X[2].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, X[4].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "IfStmt",
		NTType:     73,
		Index:      140,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				elseLabel := NewLabel()
				afterLabel := NewLabel()
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[1].(Node).place))
				n.code = append(n.code, X[2].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
				n.code = append(n.code, X[4].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IfStmt : kwdIf Expression Block kwdElse IfStmt	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[1].(Node).place))
                        n.code = append(n.code, X[2].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, X[4].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "IfStmt",
		NTType:     73,
		Index:      141,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				elseLabel := NewLabel()
				afterLabel := NewLabel()
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[1].(Node).place))
				n.code = append(n.code, X[2].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
				n.code = append(n.code, X[4].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IfStmt : kwdIf SimpleStmt terminator Expression Block	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        afterLabel := NewLabel()
                        n.code = append(n.code, X[3].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[3].(Node).place))
                        n.code = append(n.code, X[4].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "IfStmt",
		NTType:     73,
		Index:      142,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				afterLabel := NewLabel()
				n.code = append(n.code, X[3].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[3].(Node).place))
				n.code = append(n.code, X[4].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IfStmt : kwdIf SimpleStmt terminator Expression Block kwdElse IfStmt	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, X[3].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[3].(Node).place))
                        n.code = append(n.code, X[4].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, X[6].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil

                } () >>`,
		Id:         "IfStmt",
		NTType:     73,
		Index:      143,
		NumSymbols: 7,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				elseLabel := NewLabel()
				afterLabel := NewLabel()
				n.code = append(n.code, X[3].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[3].(Node).place))
				n.code = append(n.code, X[4].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
				n.code = append(n.code, X[6].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil

			}()
		},
	},
	ProdTabEntry{
		String: `IfStmt : kwdIf SimpleStmt terminator Expression Block kwdElse Block	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, X[3].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[3].(Node).place))
                        n.code = append(n.code, X[4].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, X[6].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "IfStmt",
		NTType:     73,
		Index:      144,
		NumSymbols: 7,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				elseLabel := NewLabel()
				afterLabel := NewLabel()
				n.code = append(n.code, X[3].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, X[3].(Node).place))
				n.code = append(n.code, X[4].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
				n.code = append(n.code, X[6].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `SwitchStmt : ExprSwitchStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "SwitchStmt",
		NTType:     74,
		Index:      145,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ExprSwitchStmt : kwdSwitch Expression "{" RepeatTerminator RepeatExprCaseClause "}"	<< func() (Attrib, error) {
                                n := Node{"", X[1].(Node).code}
                                caseLabels := []string{}
                                caseStmts := X[4].(Node).code
                                caseTemporaries := utils.SplitAndSanitize(X[4].(Node).place, ",")
                                afterLabel := NewLabel()
                                defaultLabel := afterLabel
                                // The last value in caseTemporaries will be the place value
                                // returned by Empty (arising from RepeatExprCaseClause -> Empty).
                                // This has to be ignored.
                                for k, v := range caseTemporaries[:len(caseTemporaries)-1] {
                                        caseLabel := NewLabel()
                                        caseLabels = append(caseLabels, caseLabel)
                                        n.code = append(n.code, caseStmts[2*k])
                                        if strings.TrimSpace(v) == "default" {
                                                defaultLabel = caseLabel
                                        } else {
                                                n.code = append(n.code, fmt.Sprintf("beq, %s, %s, %s", caseLabel, X[1].(Node).place, v))
                                        }
                                }
                                n.code = append(n.code, fmt.Sprintf("j, %s", defaultLabel))
                                for k, v := range caseLabels {
                                        n.code = append(n.code, fmt.Sprintf("label, %s", v))
                                        n.code = append(n.code, caseStmts[2*k+1])
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                }
                                n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                                return n, nil
                        } () >>`,
		Id:         "ExprSwitchStmt",
		NTType:     75,
		Index:      146,
		NumSymbols: 6,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				caseLabels := []string{}
				caseStmts := X[4].(Node).code
				caseTemporaries := utils.SplitAndSanitize(X[4].(Node).place, ",")
				afterLabel := NewLabel()
				defaultLabel := afterLabel
				// The last value in caseTemporaries will be the place value
				// returned by Empty (arising from RepeatExprCaseClause -> Empty).
				// This has to be ignored.
				for k, v := range caseTemporaries[:len(caseTemporaries)-1] {
					caseLabel := NewLabel()
					caseLabels = append(caseLabels, caseLabel)
					n.code = append(n.code, caseStmts[2*k])
					if strings.TrimSpace(v) == "default" {
						defaultLabel = caseLabel
					} else {
						n.code = append(n.code, fmt.Sprintf("beq, %s, %s, %s", caseLabel, X[1].(Node).place, v))
					}
				}
				n.code = append(n.code, fmt.Sprintf("j, %s", defaultLabel))
				for k, v := range caseLabels {
					n.code = append(n.code, fmt.Sprintf("label, %s", v))
					n.code = append(n.code, caseStmts[2*k+1])
					n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
				}
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatExprCaseClause : ExprCaseClause RepeatExprCaseClause	<< func() (Attrib, error) {
                                n := Node{"", X[0].(Node).code}
                                n.code = append(n.code, X[1].(Node).code...)
                                n.place = fmt.Sprintf("%s, %s", X[0].(Node).place, X[1].(Node).place)
                                return n, nil
                        } () >>`,
		Id:         "RepeatExprCaseClause",
		NTType:     76,
		Index:      147,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[1].(Node).code...)
				n.place = fmt.Sprintf("%s, %s", X[0].(Node).place, X[1].(Node).place)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `RepeatExprCaseClause : empty	<< func() (Attrib, error) {
                                return Node{"", []string{}}, nil
                        } () >>`,
		Id:         "RepeatExprCaseClause",
		NTType:     76,
		Index:      148,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ExprCaseClause : ExprSwitchCase ":" RepeatTerminator StatementList	<< func() (Attrib, error) {
                                n := Node{X[0].(Node).place, []string{}}
                                exprCode := ""
                                for _, v := range X[0].(Node).code {
                                        exprCode += v
                                        exprCode += "\n"
                                }
                                n.code = append(n.code, exprCode)
                                stmtCode := ""
                                for _, v := range X[3].(Node).code {
                                        stmtCode += v
                                        stmtCode += "\n"
                                }
                                n.code = append(n.code, stmtCode)
                                return n, nil
                        } () >>`,
		Id:         "ExprCaseClause",
		NTType:     77,
		Index:      149,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{X[0].(Node).place, []string{}}
				exprCode := ""
				for _, v := range X[0].(Node).code {
					exprCode += v
					exprCode += "\n"
				}
				n.code = append(n.code, exprCode)
				stmtCode := ""
				for _, v := range X[3].(Node).code {
					stmtCode += v
					stmtCode += "\n"
				}
				n.code = append(n.code, stmtCode)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ExprSwitchCase : kwdCase Expression	<< func() (Attrib, error) {
                                return Node{X[1].(Node).place, X[1].(Node).code}, nil
                        } () >>`,
		Id:         "ExprSwitchCase",
		NTType:     78,
		Index:      150,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[1].(Node).place, X[1].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ExprSwitchCase : kwdDefault	<< func() (Attrib, error) {
                                return Node{"default", []string{}}, nil
                        } () >>`,
		Id:         "ExprSwitchCase",
		NTType:     78,
		Index:      151,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"default", []string{}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForStmt : kwdFor Block	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        for _, v := range X[1].(Node).code {
                                v := strings.TrimSpace(v)
                                if v == "break" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                } else if v == "continue" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                                } else {
                                        n.code = append(n.code, v)
                                }
                        }
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "ForStmt",
		NTType:     79,
		Index:      152,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				startLabel := NewLabel()
				afterLabel := NewLabel()
				n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
				for _, v := range X[1].(Node).code {
					v := strings.TrimSpace(v)
					if v == "break" {
						n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
					} else if v == "continue" {
						n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
					} else {
						n.code = append(n.code, v)
					}
				}
				n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForStmt : kwdFor Condition Block	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        n.code = append(n.code, X[1].(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[1].(Node).place))
                        for _, v := range X[2].(Node).code {
                                v := strings.TrimSpace(v)
                                if v == "break" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                } else if v == "continue" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                                } else {
                                        n.code = append(n.code, v)
                                }
                        }
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "ForStmt",
		NTType:     79,
		Index:      153,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				startLabel := NewLabel()
				afterLabel := NewLabel()
				n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
				n.code = append(n.code, X[1].(Node).code...)
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[1].(Node).place))
				for _, v := range X[2].(Node).code {
					v := strings.TrimSpace(v)
					if v == "break" {
						n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
					} else if v == "continue" {
						n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
					} else {
						n.code = append(n.code, v)
					}
				}
				n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForStmt : kwdFor ForClause Block	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, X[1].(Node).code[0]) // init statement
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        n.code = append(n.code, X[1].(Node).code[1]) // condition
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[1].(Node).place))
                        for _, v := range X[2].(Node).code {
                                v := strings.TrimSpace(v)
                                if v == "break" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                } else if v == "continue" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                                } else {
                                        n.code = append(n.code, v)
                                }
                        }
                        n.code = append(n.code, X[1].(Node).code[2]) // post statement
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>`,
		Id:         "ForStmt",
		NTType:     79,
		Index:      154,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				startLabel := NewLabel()
				afterLabel := NewLabel()
				n.code = append(n.code, X[1].(Node).code[0]) // init statement
				n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
				n.code = append(n.code, X[1].(Node).code[1]) // condition
				n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, X[1].(Node).place))
				for _, v := range X[2].(Node).code {
					v := strings.TrimSpace(v)
					if v == "break" {
						n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
					} else if v == "continue" {
						n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
					} else {
						n.code = append(n.code, v)
					}
				}
				n.code = append(n.code, X[1].(Node).code[2]) // post statement
				n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
				n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : terminator terminator	<< func() (Attrib, error) {
                      // When Condition is not specified, do an endless loop by
                      // initializing the place value to 1.
                      return Node{"1", []string{"", "", ""}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      155,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// When Condition is not specified, do an endless loop by
				// initializing the place value to 1.
				return Node{"1", []string{"", "", ""}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : InitStmt terminator terminator	<< func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range X[0].(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        return Node{"1", []string{initStmtCode, "", ""}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      156,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				initStmtCode := ""
				for _, v := range X[0].(Node).code {
					initStmtCode += v
					initStmtCode += "\n"
				}
				return Node{"1", []string{initStmtCode, "", ""}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : terminator Condition terminator	<< func() (Attrib, error) {
                        condCode := ""
                        for _, v := range X[1].(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        return Node{X[1].(Node).place, []string{"", condCode, ""}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      157,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				condCode := ""
				for _, v := range X[1].(Node).code {
					condCode += v
					condCode += "\n"
				}
				return Node{X[1].(Node).place, []string{"", condCode, ""}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : terminator terminator PostStmt	<< func() (Attrib, error) {
                        postStmtCode := ""
                        for _, v := range X[2].(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{"1", []string{"", "", postStmtCode}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      158,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				postStmtCode := ""
				for _, v := range X[2].(Node).code {
					postStmtCode += v
					postStmtCode += "\n"
				}
				return Node{"1", []string{"", "", postStmtCode}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : InitStmt terminator Condition terminator	<< func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range X[0].(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        condCode := ""
                        for _, v := range X[2].(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        return Node{X[2].(Node).place, []string{initStmtCode, condCode, ""}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      159,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				initStmtCode := ""
				for _, v := range X[0].(Node).code {
					initStmtCode += v
					initStmtCode += "\n"
				}
				condCode := ""
				for _, v := range X[2].(Node).code {
					condCode += v
					condCode += "\n"
				}
				return Node{X[2].(Node).place, []string{initStmtCode, condCode, ""}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : InitStmt terminator terminator PostStmt	<< func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range X[0].(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        postStmtCode := ""
                        for _, v := range X[3].(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{"1", []string{initStmtCode, "", postStmtCode}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      160,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				initStmtCode := ""
				for _, v := range X[0].(Node).code {
					initStmtCode += v
					initStmtCode += "\n"
				}
				postStmtCode := ""
				for _, v := range X[3].(Node).code {
					postStmtCode += v
					postStmtCode += "\n"
				}
				return Node{"1", []string{initStmtCode, "", postStmtCode}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : terminator Condition terminator PostStmt	<< func() (Attrib, error) {
                        condCode := ""
                        for _, v := range X[1].(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        postStmtCode := ""
                        for _, v := range X[3].(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{X[1].(Node).place, []string{"", condCode, postStmtCode}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      161,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				condCode := ""
				for _, v := range X[1].(Node).code {
					condCode += v
					condCode += "\n"
				}
				postStmtCode := ""
				for _, v := range X[3].(Node).code {
					postStmtCode += v
					postStmtCode += "\n"
				}
				return Node{X[1].(Node).place, []string{"", condCode, postStmtCode}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ForClause : InitStmt terminator Condition terminator PostStmt	<< func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range X[0].(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        condCode := ""
                        for _, v := range X[2].(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        postStmtCode := ""
                        for _, v := range X[4].(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{X[2].(Node).place, []string{initStmtCode, condCode, postStmtCode}}, nil
              } () >>`,
		Id:         "ForClause",
		NTType:     80,
		Index:      162,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				initStmtCode := ""
				for _, v := range X[0].(Node).code {
					initStmtCode += v
					initStmtCode += "\n"
				}
				condCode := ""
				for _, v := range X[2].(Node).code {
					condCode += v
					condCode += "\n"
				}
				postStmtCode := ""
				for _, v := range X[4].(Node).code {
					postStmtCode += v
					postStmtCode += "\n"
				}
				return Node{X[2].(Node).place, []string{initStmtCode, condCode, postStmtCode}}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `InitStmt : SimpleStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "InitStmt",
		NTType:     81,
		Index:      163,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `PostStmt : SimpleStmt	<< func() (Attrib, error) {
                        return Node{"", X[0].(Node).code}, nil
                } () >>`,
		Id:         "PostStmt",
		NTType:     82,
		Index:      164,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{"", X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Condition : Expression	<< func() (Attrib, error) {
                        return Node{X[0].(Node).place, X[0].(Node).code}, nil
                } () >>`,
		Id:         "Condition",
		NTType:     83,
		Index:      165,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{X[0].(Node).place, X[0].(Node).code}, nil
			}()
		},
	},
	ProdTabEntry{
		String: `DeferStmt : "defer" PrimaryExpr Arguments	<< func() (Attrib, error) {
                        // Add code corresponding to the arguments.
                        n := Node{"", X[2].(Node).code}
                        argExpr := utils.SplitAndSanitize(X[2].(Node).place, ",")
                        for k, v := range argExpr {
                              n.code = append(n.code, fmt.Sprintf("=, %s.%d, %s", X[1].(Node).place, k, v))
                        }
                        n.place = NewTmp()
                        // The code for the actual function call needs to be pushed to the defer stack.
                        deferCode := make(DeferStackItem, 0)
                        deferCode = append(deferCode, fmt.Sprintf("call, %s", X[1].(Node).place))
                        deferCode = append(deferCode, fmt.Sprintf("store, %s", n.place))
                        deferStack.Push(deferCode)
                        return n, nil
                } () >>`,
		Id:         "DeferStmt",
		NTType:     84,
		Index:      166,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				// Add code corresponding to the arguments.
				n := Node{"", X[2].(Node).code}
				argExpr := utils.SplitAndSanitize(X[2].(Node).place, ",")
				for k, v := range argExpr {
					n.code = append(n.code, fmt.Sprintf("=, %s.%d, %s", X[1].(Node).place, k, v))
				}
				n.place = NewTmp()
				// The code for the actual function call needs to be pushed to the defer stack.
				deferCode := make(DeferStackItem, 0)
				deferCode = append(deferCode, fmt.Sprintf("call, %s", X[1].(Node).place))
				deferCode = append(deferCode, fmt.Sprintf("store, %s", n.place))
				deferStack.Push(deferCode)
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `PrintIntStmt : "printInt" Expression	<< func() (Attrib, error) {
                        n := Node{"", X[1].(Node).code}
                        n.code = append(n.code, fmt.Sprintf("printInt, %s, %s", X[1].(Node).place, X[1].(Node).place))
                        return n, nil
                } () >>`,
		Id:         "PrintIntStmt",
		NTType:     85,
		Index:      167,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[1].(Node).code}
				n.code = append(n.code, fmt.Sprintf("printInt, %s, %s", X[1].(Node).place, X[1].(Node).place))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IncDecStmt : Expression "++"	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, fmt.Sprintf("+, %s, %s, 1", X[0].(Node).place, X[0].(Node).place))
                        return n, nil
                } () >>`,
		Id:         "IncDecStmt",
		NTType:     86,
		Index:      168,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, fmt.Sprintf("+, %s, %s, 1", X[0].(Node).place, X[0].(Node).place))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `IncDecStmt : Expression "--"	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, fmt.Sprintf("-, %s, %s, 1", X[0].(Node).place, X[0].(Node).place))
                        return n, nil
                } () >>`,
		Id:         "IncDecStmt",
		NTType:     86,
		Index:      169,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, fmt.Sprintf("-, %s, %s, 1", X[0].(Node).place, X[0].(Node).place))
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Assignment : ExpressionList assignOp ExpressionList	<< func() (Attrib, error) {
                        op := string(X[1].(*token.Token).Lit)[0]
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        leftExpr := utils.SplitAndSanitize(X[0].(Node).place, ",")
                        rightExpr := utils.SplitAndSanitize(X[2].(Node).place, ",")
                        for k, v := range leftExpr {
                                n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", op, v, v, rightExpr[k]))
                                _, ok := symTab[v]
                                if ok {
                                        if symTab[v][1] == "array" {
                                                arrayInfo := utils.SplitAndSanitize(symTab[v][0], ",")
                                                // arrayInfo contains the following info -
                                                //      0th index: array name
                                                //      1st index: array index
                                                n.code = append(n.code, fmt.Sprintf("into, %s, %s, %s, %s", arrayInfo[0], arrayInfo[0], arrayInfo[1], v))
                                        }
                                }
                        }
                        return n, nil
                } () >>`,
		Id:         "Assignment",
		NTType:     87,
		Index:      170,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				op := string(X[1].(*token.Token).Lit)[0]
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				leftExpr := utils.SplitAndSanitize(X[0].(Node).place, ",")
				rightExpr := utils.SplitAndSanitize(X[2].(Node).place, ",")
				for k, v := range leftExpr {
					n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", op, v, v, rightExpr[k]))
					_, ok := symTab[v]
					if ok {
						if symTab[v][1] == "array" {
							arrayInfo := utils.SplitAndSanitize(symTab[v][0], ",")
							// arrayInfo contains the following info -
							//      0th index: array name
							//      1st index: array index
							n.code = append(n.code, fmt.Sprintf("into, %s, %s, %s, %s", arrayInfo[0], arrayInfo[0], arrayInfo[1], v))
						}
					}
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Assignment : ExpressionList "=" ExpressionList	<< func() (Attrib, error) {
                        n := Node{"", X[0].(Node).code}
                        n.code = append(n.code, X[2].(Node).code...)
                        leftExpr := utils.SplitAndSanitize(X[0].(Node).place, ",")
                        rightExpr := utils.SplitAndSanitize(X[2].(Node).place, ",")
                        for k, v := range leftExpr {
                                if len(currSymTab.varSymTab[GetRealName(v)]) >= 2 && currSymTab.varSymTab[GetRealName(v)][1] == "pointer" {
                                        if len(rightExpr[k]) >= 7 && rightExpr[k][:7] == "pointer" {
                                                currSymTab.varSymTab[GetRealName(v)][3] = currSymTab.varSymTab[GetRealName(rightExpr[k][8:])][0]
                                        } else {
                                                currSymTab.varSymTab[GetRealName(v)][3] = currSymTab.varSymTab[GetRealName(rightExpr[k])][3]
                                        }
                                } else if len(rightExpr[k]) >= 5 && rightExpr[k][:5] == "deref" && len(v) >= 5 && v[:5] == "deref" {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v[6:])][3], currSymTab.varSymTab[GetRealName(rightExpr[k][6:])][3]))
                                } else if len(rightExpr[k]) >= 5 && rightExpr[k][:5] == "deref" {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v)][0], currSymTab.varSymTab[GetRealName(rightExpr[k][6:])][3]))
                                } else if len(v) >= 5 && v[:5] == "deref" {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v[6:])][3], rightExpr[k]))
                                } else {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, rightExpr[k]))
                                        _, ok := symTab[v]
                                        if ok {
                                                if symTab[v][1] == "array" {
                                                        arrayInfo := utils.SplitAndSanitize(symTab[v][0], ",")
                                                        // arrayInfo[0]: array name
                                                        // arrayInfo[1]: array index
                                                        n.code = append(n.code, fmt.Sprintf("into, %s, %s, %s, %s", arrayInfo[0], arrayInfo[0], arrayInfo[1], v))
                                                }
                                        }
                                }
                        }
                        return n, nil
                } () >>`,
		Id:         "Assignment",
		NTType:     87,
		Index:      171,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", X[0].(Node).code}
				n.code = append(n.code, X[2].(Node).code...)
				leftExpr := utils.SplitAndSanitize(X[0].(Node).place, ",")
				rightExpr := utils.SplitAndSanitize(X[2].(Node).place, ",")
				for k, v := range leftExpr {
					if len(currSymTab.varSymTab[GetRealName(v)]) >= 2 && currSymTab.varSymTab[GetRealName(v)][1] == "pointer" {
						if len(rightExpr[k]) >= 7 && rightExpr[k][:7] == "pointer" {
							currSymTab.varSymTab[GetRealName(v)][3] = currSymTab.varSymTab[GetRealName(rightExpr[k][8:])][0]
						} else {
							currSymTab.varSymTab[GetRealName(v)][3] = currSymTab.varSymTab[GetRealName(rightExpr[k])][3]
						}
					} else if len(rightExpr[k]) >= 5 && rightExpr[k][:5] == "deref" && len(v) >= 5 && v[:5] == "deref" {
						n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v[6:])][3], currSymTab.varSymTab[GetRealName(rightExpr[k][6:])][3]))
					} else if len(rightExpr[k]) >= 5 && rightExpr[k][:5] == "deref" {
						n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v)][0], currSymTab.varSymTab[GetRealName(rightExpr[k][6:])][3]))
					} else if len(v) >= 5 && v[:5] == "deref" {
						n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v[6:])][3], rightExpr[k]))
					} else {
						n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, rightExpr[k]))
						_, ok := symTab[v]
						if ok {
							if symTab[v][1] == "array" {
								arrayInfo := utils.SplitAndSanitize(symTab[v][0], ",")
								// arrayInfo[0]: array name
								// arrayInfo[1]: array index
								n.code = append(n.code, fmt.Sprintf("into, %s, %s, %s, %s", arrayInfo[0], arrayInfo[0], arrayInfo[1], v))
							}
						}
					}
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `ShortVarDecl : IdentifierList shortAssign ExpressionList	<< func() (Attrib, error) {
                        n := Node{"", []string{}}
                        // TODO: Structs do not support multiple short declarations in a
                        // single statement for now.
                        exprName := X[2].(Node).place
                        if len(exprName) >= 6 && exprName[:6] == "struct" {
                                // NOTE: The following index calculations assume that
                                // struct names cannot include a ':' character.
                                colonIndex := strings.LastIndexAny(exprName, ":")
                                structLen, err := strconv.Atoi(exprName[7:colonIndex])
                                if err != nil {
                                        return nil, err
                                }
                                // TODO: Multiple struct initializations are not handled currently.
                                structName := X[0].(Node).code[0]
                                // keeping structName in the symbol table with type as Struct
                                currSymTab.varSymTab[structName] = []string{structName, "struct"}
                                // The individual struct member initializers can contain
                                // expressions whose code need to be added before the
                                // members are initialized.
                                n.code = append(n.code, X[2].(Node).code[2*structLen:]...)
                                // Add code for struct member initializations.
                                var varName, varVal string
                                for k, v := range X[2].(Node).code[:2*structLen] {
                                        if k % 2 == 0 {
                                                // Member names are located at even locations.
                                                varName = v
                                        } else {
                                                // (Initialized) member values are located at odd locations.
                                                varVal = v
                                                renamedVar := RenameVariable(fmt.Sprintf("%s.%s", structName, varName))
                                                currSymTab.varSymTab[fmt.Sprintf("%s.%s", structName, varName)] = []string{renamedVar, "int"}
                                                // TODO: Add the struct initializations to symbol table. Also,
                                                // handle member accesses as -
                                                //      node := Node{1}
                                                //      b := node.val  // member access
                                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, varVal))
                                        }
                                }
                        } else {
                                n.code = X[2].(Node).code
                                expr := utils.SplitAndSanitize(X[2].(Node).place, ",")
                                for k, v := range X[0].(Node).code {
                                        renamedVar := RenameVariable(v)
                                        _, ok := currSymTab.varSymTab[v]
                                        if !ok {
                                                // TODO: All types are int currently.
                                                if len(expr[k]) >= 7 && expr[k][0:7] == "pointer" {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "pointer", "int", expr[k][8:]}
                                                } else if len(currSymTab.varSymTab[GetRealName(expr[k])]) >= 2 && currSymTab.varSymTab[GetRealName(expr[k])][1] == "pointer" {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "pointer", currSymTab.varSymTab[GetRealName(expr[k])][2] , currSymTab.varSymTab[GetRealName(expr[k])][3]}
                                                } else if len(expr[k]) >= 5 && expr[k][0:5] == "deref" {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "int"}
                                                } else {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "int"}
                                                }
                                        } else {
                                                return nil, errors.New(fmt.Sprintf("%s already declared", v))
                                        }
                                        if len(expr[k]) >= 5 && expr[k][:5] == "array" {
                                                // TODO: rename arrays
                                                n.code = append(n.code, fmt.Sprintf("decl, %s, %s", renamedVar, expr[k][6:]))
                                        } else if len(expr[k]) >= 5 && expr[k][0:5] == "deref" {
                                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, currSymTab.varSymTab[GetRealName(expr[k][6:])][3]))
                                        } else if len(currSymTab.varSymTab[v]) >= 2 && currSymTab.varSymTab[v][1] != "pointer" {
                                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                                        }
                                }
                        }
                        return n, nil
                } () >>`,
		Id:         "ShortVarDecl",
		NTType:     88,
		Index:      172,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				n := Node{"", []string{}}
				// TODO: Structs do not support multiple short declarations in a
				// single statement for now.
				exprName := X[2].(Node).place
				if len(exprName) >= 6 && exprName[:6] == "struct" {
					// NOTE: The following index calculations assume that
					// struct names cannot include a ':' character.
					colonIndex := strings.LastIndexAny(exprName, ":")
					structLen, err := strconv.Atoi(exprName[7:colonIndex])
					if err != nil {
						return nil, err
					}
					// TODO: Multiple struct initializations are not handled currently.
					structName := X[0].(Node).code[0]
					// keeping structName in the symbol table with type as Struct
					currSymTab.varSymTab[structName] = []string{structName, "struct"}
					// The individual struct member initializers can contain
					// expressions whose code need to be added before the
					// members are initialized.
					n.code = append(n.code, X[2].(Node).code[2*structLen:]...)
					// Add code for struct member initializations.
					var varName, varVal string
					for k, v := range X[2].(Node).code[:2*structLen] {
						if k%2 == 0 {
							// Member names are located at even locations.
							varName = v
						} else {
							// (Initialized) member values are located at odd locations.
							varVal = v
							renamedVar := RenameVariable(fmt.Sprintf("%s.%s", structName, varName))
							currSymTab.varSymTab[fmt.Sprintf("%s.%s", structName, varName)] = []string{renamedVar, "int"}
							// TODO: Add the struct initializations to symbol table. Also,
							// handle member accesses as -
							//      node := Node{1}
							//      b := node.val  // member access
							n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, varVal))
						}
					}
				} else {
					n.code = X[2].(Node).code
					expr := utils.SplitAndSanitize(X[2].(Node).place, ",")
					for k, v := range X[0].(Node).code {
						renamedVar := RenameVariable(v)
						_, ok := currSymTab.varSymTab[v]
						if !ok {
							// TODO: All types are int currently.
							if len(expr[k]) >= 7 && expr[k][0:7] == "pointer" {
								currSymTab.varSymTab[v] = []string{renamedVar, "pointer", "int", expr[k][8:]}
							} else if len(currSymTab.varSymTab[GetRealName(expr[k])]) >= 2 && currSymTab.varSymTab[GetRealName(expr[k])][1] == "pointer" {
								currSymTab.varSymTab[v] = []string{renamedVar, "pointer", currSymTab.varSymTab[GetRealName(expr[k])][2], currSymTab.varSymTab[GetRealName(expr[k])][3]}
							} else if len(expr[k]) >= 5 && expr[k][0:5] == "deref" {
								currSymTab.varSymTab[v] = []string{renamedVar, "int"}
							} else {
								currSymTab.varSymTab[v] = []string{renamedVar, "int"}
							}
						} else {
							return nil, errors.New(fmt.Sprintf("%s already declared", v))
						}
						if len(expr[k]) >= 5 && expr[k][:5] == "array" {
							// TODO: rename arrays
							n.code = append(n.code, fmt.Sprintf("decl, %s, %s", renamedVar, expr[k][6:]))
						} else if len(expr[k]) >= 5 && expr[k][0:5] == "deref" {
							n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, currSymTab.varSymTab[GetRealName(expr[k][6:])][3]))
						} else if len(currSymTab.varSymTab[v]) >= 2 && currSymTab.varSymTab[v][1] != "pointer" {
							n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
						}
					}
				}
				return n, nil
			}()
		},
	},
	ProdTabEntry{
		String: `Label : identifier	<< func() (Attrib, error) {
                       return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
                 } () >>`,
		Id:         "Label",
		NTType:     89,
		Index:      173,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib) (Attrib, error) {
			return func() (Attrib, error) {
				return Node{string(X[0].(*token.Token).Lit), []string{}}, nil
			}()
		},
	},
}
